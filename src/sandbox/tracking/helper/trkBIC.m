function bic = trkBIC(Features, SplitPoint, PenaltyWeight, LowEnergyPct)
% function bic = trkEB_BIC(Features, SplitPoint, PenaltyWeight, LowEnergyPct)
% Bayesian Information Criteria test for a set of row feature vectors:
%	H0 : Features all generated by one source which can be
%		modeled as a multivariate normal distribution.
%	H1 : Features(1:SplitPoint, :) generated by source 1,
%	     Features(SplitPoint+1:end, :) generated by source 2.
%	     We assume both sources can be modeled as normal
%		distributions.
%
% Features is a set row-oriented feature vectors.  Features(1,:) is
% assumed to contain energy and will be removed before performing the
% test.  It is advantageous to remove low energy vectors prior to the
% test.  The rate LowEnergyPct indicates what percentage of the vectors
% will be removed before the test, lowest energy vectors are removed
% first.
%
% Returns the change in BIC value between H0 and H1.
%
% This code is copyrighted 2003-2004 by Marie Roch and Yanliang Cheng.
% e-mail:  marie.roch@ieee.org
%
% Permission is granted to use this code for non-commercial research
% purposes.  Use of this code, or programs derived from this code for
% commercial purposes without the consent of the author is strictly
% prohibited. 


if nargin < 4
  LowEnergyPct = 0;
end

% Find remaining indices for left and right sides of the split point
% after dropping the low energy frames.
[LeftIndices, RightIndices] = ...
    trkDropLowIndicesAcrossSplit(SplitPoint, Features(:,1), ...
                                      LowEnergyPct);

Dim = size(Features, 2);  % Determine dimension of the feature vectors

% find the number of vectors remaining in H0 and H1.
NLeft = length(LeftIndices);    % H1
NRight = length(RightIndices);  
NAll = NLeft + NRight;          % H0

Left = Features(LeftIndices, :);
Right = Features(RightIndices, :);
All = [Left; Right];

% compute the penalty factor
%
% The number of parameters is dependent upon the number of means
% and the number of covariance parameters.  The covariance matrix
% is symmetric, meaning that there are only 1 + 2 + 3 + ... + Dim
% covariance parameters.
%
% 1 + 2 + 3 + ... + Dim = Dim * (1 + Dim) / 2
% H0: Dim + .5*Dim*(1+Dim)    only one distribution
% H1: 2 [ Dim + .5*Dim*(1+Dim) ]      two distributions
% So penalize by the difference in the number of parameters. 
penalty = 0.5*(Dim+(0.5*Dim*(Dim+1)))*log(NAll);

% log likelihood ratio
LLR = NAll * log(trkDetSymmetric(cov(All))) ...
    - NLeft * log(trkDetSymmetric(cov(Left))) ...
    - NRight * log(trkDetSymmetric(cov(Right))); 

% compute BIC value
bic = LLR - PenaltyWeight * penalty;

function Det = trkDetSymmetric(SymmetricMatrix)
% Find the determinant of a symmetric matrix.
% No check is made to see if the matrix is actually symmetric.
% Rounding errors which result in low magnitude negative determinants
% will be set to zero.

Det = det(SymmetricMatrix);
if Det <= 0
  % If the condition number is large, assume accuracy problems
  % and set determinant to near zero.
  if cond(SymmetricMatrix) > 1e4
    Det = NaN;
  else
    warning('Matrix was not positive definite!')
  end
end

