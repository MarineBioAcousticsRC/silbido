function bic = trkEB_BIC(Features,  SplitPoint, PenaltyWeight, Prior, ...
			 Statistic, LowEnergyPct)
% function bic = trkEB_BIC(Features, SplitPoint, PenaltyWeight, Prior,
%			   Statistic, LowEnergyPct)
% Bayesian Information Criteria test for a set of row feature vectors:
%	H0 : Features all generated by one source which is normal with
%		independent components.
%	H1 : Features(1:SplitPoint, :) generated by source 1,
%	     Features(SplitPoint+1:end, :) generated by source 2.
%		Both sources are normal with independent components.
%
% Features is a set row-oriented feature vectors.  Features(1,:) is
% assumed to contain energy and will be removed before performing the
% test.  It is advantageous to remove low energy vectors prior to the
% test.  The rate LowEnergyPct indicates what percentage of the vectors
% will be removed before the test, lowest energy vectors are removed
% first.
%
% Before computing the BIC, the estimated distributions are adapted using
% a Bayesian Maximum a-posteriori (MAP) adaptation of the normal
% distributions.  
%
% Returns the change in BIC value between H0 and H1.
%
% Details of the algorithm can be found in:
% 
% "Speaker Segmentation Using the MAP-Adapted Bayesian Information
% Criterion", Marie Roch and Yanliang Cheng, Odyssey 2004, May 2004.
%
% This code is copyrighted 2003-2004 by Marie Roch and Yanliang Cheng.
% e-mail:  marie.roch@ieee.org
%
% Permission is granted to use this code for non-commercial research
% purposes.  Use of this code, or programs derived from this code for
% commercial purposes without the consent of the author is strictly
% prohibited. 

if nargin < 6
  LowEnergyPct = 0;
end

%
% According to BIC algorithm we compute the determinants of 
% covariance of Matrix, Up and Down, prepresenting them as
% DETm, DETup, DETd respectively. Let N, Nup, Nd represent 
% size of Matrix, Up and Down. Then the maxium likelihood ratio
%   R(Chg) = N* log(DETm)- Nup* log(DETup) - Nd*log(DETd)
% let d reprent the dimension of the space of Matrix, then
% the penalty is computed P=.5*(d+.5*d(d+1))* logN
% and BIC(Chg) = R(Chg) -w*P
% where w is the penalty weight, we choose w = 1.2 for now.

% Input:    Matrix data, frame energy, divide point for each window
%           alph, beta, mu and tao as priors for sphere files
% Ouput:    Empirical BIC value

% Assume that each observation ~ N(M, R)
% Then, assuming components are independent,
% R ~ gamma(alpha, beta)
% M|R ~ N(mu, tau * r)

% We have estimated our prior alpha, beta, mu, & tau  previously.

% We wish to account for new observed information and update our
% estimate of the priors.  Then, we will take R to be the mean
% of the updated distribution.

% mean(R) = alpha'/beta'
% alpha' = alpha + n/2
% beta' = beta + 1/2 sum_of_the_deviates^2 +
%		tau * n * sum_of_the_deviates^2 / (2 (tau + n))
% 
% We assume that each distribution (all, left, right)
% has a R ~ gamma(alpha, beta)

% We want to estimate a new posterior given the data. 
% We must estimate alpha', beta':

% Number of feature vectors x number of dimensions
[N, d]  = size(Features);

% remove indices with low energy
Energy = Features(:,1);  % store the energy in separate vector
Features(:,1) = [];   % remove the energy column

% Find remaining indices for left and right sides of the split point
% after dropping the low energy frames.
[LeftIndices, RightIndices] = ...
    trkDropLowIndicesAcrossSplit(SplitPoint, Features(:,1), ...
                                      LowEnergyPct);

% left and right segments after removing low energy vectors
left = Features(LeftIndices, :);
right = Features(RightIndices, :);
seg = [left; right];
N_left = size(left, 1);
N_right = size(right, 1);
N_all = size(seg, 1);

% Use Bayesian adaptation to determine the varainces for these segments.
R_all = Adapt(seg, Prior, Statistic);
R_left = Adapt(left, Prior, Statistic);
R_right = Adapt(right, Prior, Statistic);

R = N_all*log(det(R_all))-N_left*log(det(R_left))-N_right*log(det(R_right)); 
% In standard BIC, we count the d(d+1)/2 variance/covariance
% parameters.  In eBIC with independence assumption, there are
% only d variance/covariance parameters.
% .5 * (d + d) * log(# items)
Penalty = d*log(N_all);

bic = R - PenaltyWeight * Penalty;


% MAP Adaptation ----------------------------------------
function Variance = Adapt(Data, Prior, Statistic)

N = size(Data, 1);
EstMean = mean(Data);
EstVar = var(Data);
SumSquaredDeviations = (N - 1) * EstVar;

% Determine the parameters of the posterior gamma distribution
Alpha = Prior.alpha + N / 2;
Beta = Prior.beta + .5 * SumSquaredDeviations + ...
       Prior.tau .* N .* (EstMean - Prior.mu) .^ 2 / ...
          (2 * (Prior.tau + N));


switch Statistic
 case 'mode'
  Precision = (Alpha - 1) ./ Beta;

 case 'mean'
  Precision = Alpha ./ Beta;
  
 otherwise
  error('Bad estimator method');
end

Variance = diag(1 ./ Precision);
