function Performance = ...
    dtPerformance(Filename, detected_tonals, ground_truth_tonals, varargin)
% dtPerformance (Filename, detected_tonals, ground_truth_tonals,...
%                OptionalArgs)
% Calculate performance measure: Recall and Precision
%
% Filename - Name of a audio file
%            Example - 'palmyra092007FS192-071011-230000.wav'
% detected_tonals - tonals detected by graph search algorithm
% ground_truth_tonals - ground truth tonals generated by using GUI tool
%                       dtPlotUIGroundtruth.m
% It is assumed that both sets of tonals are sorted by start time.
% Optional arguments:
%   'Framing', [Advance_ms, Length_ms] - frame advance and length in ms
%       Defaults to 1 and 2 ms respectively
%   'Noise', Method
%       Method for noise compensation in spectrogram plots.
%       It is recommended that the same noise compensation as
%       used for creating the tonal set be used.  See
%       dtSpectrogramNoiseComp for valid methods.
%   'GroundTruthCriteria', [dB, RatioAbove_SNR, MinLen] 
%       Criteria for determining whether or not to expect each ground
%       truth tonal to be detected.  When tonals are detected but we
%       did not expect them to be, they are not counted towards the
%       recall, but they will not be used to penalize the precision.
%       Default:  [-inf, .5, 0]
%       Q: Shall we include a minimum coverage parameter?
% 
% Output:
% Performance structure:
%    false_pos - file containing unmatched detections
%    detect_all - structure describing performance irregardless of SNR
%    detect_snr - structure describing performance meeting ground truth
%        criteria.
%    Both detect_all and detect_snr have the following structure:
%        detections - file containing detections matching ground truth
%        gt_idx - index of ground truth to which each detection was matched
%        det_N - # of detections
%        det_matched_N - # detections matching ground truth
%        det_falsepos_N - # detections that do not correspond to gt
%            Note:  det_matched_N + det_falsepos_N is not necessarily det_N
%            in the detect_snr structure as weak ground truth tonals may
%            be detected and we do not penalize them.
%        gt_N - # of ground truth tonals
%        gt_detected_N # of detected ground tonals
%        gt_missed_N - # of undetected ground truth tonals
%        fragment_rate - det_matched_N / gt_detected_N
%        covered_s - seconds of coverage for detected ground truth tonals
%        length_s - length of ground truth tonals that were detected
%    
% Example call:
% [tonals graphs] = dtTonalsTracking(File, t0, t1);
% dtPlotUIGroundtruth(File, tonals, t0, t1);
% dtPerformance(File, tonals, ground_truth_tonal);

tic;

SNR_dB = -inf;  % threshold
RatioAbove_SNR = .333;
NoiseSub = 'median';

%warning off;
import tonals.*;

% defaults
Length_ms = 8;  % framing
Advance_ms = 2;
MA_s = 3.0;  % moving average window for spectral means subtraction
MApad_s = MA_s/2;  % Pad by half of window on either side whenever possible
PeakTolerance_Hz = 500;  % search for peaks in ground truth +/- PeakTolerance_Hz
MatchTolerance_Hz = 350;

thr = dtThresh();

% Process arguments
error(nargchk(3, inf, nargin));
k = 1;
while k <= length(varargin)
    switch varargin{k}
        case 'Framing'
            if length(varargin{k+1}) ~= 2 || ~ isnumeri(varargin{k+1})
                error('%s must be [Advance_ms, Length_ms]', varargin{k});
            else
                Advance_ms = varargin{k+1}(1);
                Length_ms = varargin{k+1}(2);
            end
            k=k+2;
        case 'Noise'
            NoiseSub = varargin{k+1}; k=k+2;
        case 'GroundTruthCriteria'
            if ~ isnumeric(varargin{k+1}) || length(varargin{k+1}) ~= 2
                error('GroundTruthCriteria expecting [SNR_dB, RatioAbove_SNR]');
            else
                SNR_dB = varargin{k+1}(1);
                RatioAbove_SNR = varargin{k+1}(2);
                if abs(RatioAbove_SNR - .5) > .5
                    error('Expecting RatioAbove_SNR in [0, 1]');
                end
            end
            k=k+2;
        otherwise
            try
                if isnumeric(varargin{k})
                    errstr = sprintf('Bad option %f', varargin{k});
                else
                    errstr = sprintf('Bad option %s', char(varargin{k}));
                end
            catch
                errstr = sprintf('Bad option in %d''optional argument', k);
            end
            error('%s: %s', mfilename, errstr);
    end
end

header = ioReadWavHeader(Filename);  % Get header information
handle = fopen(Filename, 'rb', 'l'); % open audio data

% end of file time in s
eof_s = header.Chunks{header.dataChunk}.nSamples / header.fs;
% Frame parameters in samples
Length_s = Length_ms / 1000;
Length_samples = round(header.fs * Length_s);
Advance_s = Advance_ms / 1000;
Advance_samples = round(header.fs * Advance_s);

Nyquist_bin = floor(Length_samples/2);
bin_Hz = header.fs / Length_samples;    % Hz covered by each freq bin

thr.high_cutoff_bins = min(ceil(thr.high_cutoff_Hz/bin_Hz)+1, Nyquist_bin);
thr.low_cutoff_bins = ceil(thr.low_cutoff_Hz / bin_Hz)+1;

% save indices of freq bins that will be processed
range_bins = thr.low_cutoff_bins:thr.high_cutoff_bins;
range_binsN = length(range_bins);  % # freq bin count

% Frequency range for filtering out the overlapping tonals during
% selection process (Polynomial fit)
freq_range = bin_Hz * 3;

poly_deg = 4;   % Polynomial degree
corr_recall_cnt = 0;  % Correctly detected tonals for recall
corr_precision_cnt = 0; % Correctly detected tonals for precision
tonals_frag_cnt = 0;  % Number of tonals fragmented.
frag_cnt = 0;   % Number of fragments.



coverage = [];

Performance.falsePos = java.util.LinkedList();
detectedN = detected_tonals.size();
gtN = ground_truth_tonals.size();
% performance as compared to ground truth without consideration of
% criteria
Performance.all = initPerformance();
% somewhat of a misnomer, this is the performance when we consider
% ground truth tonals that meet a certain criteria which includes
% SNR.
Performance.snr = initPerformance();  
Performance.file = Filename;

block_s = 5;  % desired processing block size

% indicator showing which ground truth tonals have been processed
gt_processedI = zeros(gtN, 1);  
% access start/end times for each ground truth tonal
gt_times = zeros(gtN, 2);
for k=1:gtN
    t = ground_truth_tonals.get(k-1).get_time();
    gt_times(k, :) = [t(1), t(end)];
end

falsePos = detected_tonals.clone();
done = gtN == 0;
while ~ done
    % find first unprocessed ground truth
    gt_idx = 1;  % probably cheaper to search each time instead of 
                 % taking the memcpy hit we would have with deleting rows
                 % my kingdom for a good set of ADTs...
    while ~ done && gt_processedI(gt_idx)
        gt_idx = gt_idx + 1;
        done = gt_idx > gtN;
    end
    if ~ done
        %processing(gt_idx) = true;
        % Set up processing window
        start = gt_times(gt_idx, 1); 
        stop = max(gt_times(gt_idx, 2), start + block_s);
        % find everything that fits in this range
        process = gt_times(:,1) >= start & gt_times(:,2) <= stop & ...
            gt_processedI == false;
        % pad if possible, making sure we don't go pass the ends
        start = max([0, start - MApad_s]);
        stop = min([stop + MApad_s, eof_s]);

        % for now:
        fprintf('Processing %.2f s:  %f to %f:', stop-start, start, stop);
        fprintf(' %d', find(process));
        fprintf('\n');
        if 0
            for dbg_idx = find(process)'
                fprintf('%4d:  %3.3f - %3.3f\n', dbg_idx, gt_times(dbg_idx, :));
            end
        end
        
        % Read in data and compute spectrogram
        channel = channelmap(header, Filename);

        pcm = ioReadWav(handle, header, start, stop, 'Units', 's', ...
            'Channels', channel);
        
        [spec_dB, t_info, dft, clickP] = ...
            dtSpecAnal(pcm, header.fs, Length_samples, Advance_samples, ...
            0, range_bins, thr.broadband * range_binsN, ...
            thr.click_dB, NoiseSub);
        t_idx = t_info.timeidx(1:t_info.FrameLastComplete) + start;
        
        % process each ground truth tonal
        for gt_idx = find(process)'
            % find time bins corresponding to call
            indices = find(t_idx >= gt_times(gt_idx, 1) & ...
                t_idx <= gt_times(gt_idx, 2))';
            gt_tonal = ground_truth_tonals.get(gt_idx-1);
            t = gt_tonal.get_time();
            f = gt_tonal.get_freq();
            [t2, tindices] = unique(t, 'first');
            if length(t2) ~= length(t)
                fprintf('Sort problem - ground truth %d\n', gt_idx);
                % fix it
                t = t2;
                f = f(tindices);
            end
            % interpolate frequencies to current time resolution
            f_i = interp1(t, f, t_idx(indices));
            % quantize frequency 
            f_q = round(f_i / bin_Hz) - thr.low_cutoff_bins + 1;
            % ground truth was smoothed and peak SNR may not be 
            % directly on path. Create matrix to search for max within
            % +/- search_bins on frequency axis
            snr = zeros(1, length(indices));
            search = round(PeakTolerance_Hz / bin_Hz);
            lowbins = f_q - search;
            highbins = f_q + search;
            lowbins(lowbins < 1) = 1;
            lowbins(lowbins > range_binsN) = range_binsN;
            highbins(highbins < 1) = 1;
            highbins(highbins > range_binsN) = range_binsN;
            for k=1:length(indices)
                snr(k) = max(spec_dB(lowbins(k):highbins(k), indices(k)));
            end
            sorted_snr = sort(snr);
            gt_snr = sorted_snr(max(1,round((1-RatioAbove_SNR)*length(snr))));
            valid = gt_snr > SNR_dB  && gt_tonal.duration() >= thr.minlen_ms / 1000;
                
            % find overlapping detections
            deviations = [];
            matchedP = false;
            excess_t = 0;
            covered_t = 0;
            % We consider tonals that have already been matched as
            % we may have merged two accidentally.
            overlap = gt_tonal.overlapping_tonals(detected_tonals);
            
            % process overlaps
            overlap_it = overlap.iterator();
            while (overlap_it.hasNext())
                d = overlap_it.next();
                dt = d.get_time();
                df = d.get_freq();
                % find sections that overlap
                overlap_idcs = find(dt >= t(1) & dt <= t(end));
                t_ov = dt(overlap_idcs);
                f_ov = df(overlap_idcs);
                
                % interpolate ground truth frequencies for this detection
                f_interp = interp1(t,f, t_ov);
                % compute deviations
                deviation = abs(f_ov - f_interp);
                if mean(deviation) <= MatchTolerance_Hz
                    matchedP = true;
                    if falsePos.contains(d)
                        falsePos.remove(d);
                    end
                    Performance.all.detections.add(d);
                    if valid
                        Performance.snr.detections.add(d);
                    end
                    
                    % save statistics
                    deviations = [deviations; deviation];
                    excess_t = max(0, t(1)-dt(1)) + max(0, dt(end)-t(end));
                    covered_t = covered_t + t_ov(end) - t_ov(1);
                end
            end
            gt_processedI(gt_idx) = true;
            if matchedP
                Performance.all = updPerformance(...
                    Performance.all, gt_tonal, mean(deviations), ...
                    covered_t, excess_t);
                if valid
                    Performance.snr = updPerformance(...
                        Performance.snr, gt_tonal, mean(deviations), ...
                        covered_t, excess_t);
                end
            else
                Performance.all.gt_miss.add(gt_tonal);
                if valid
                    Performance.snr.gt_miss.add(gt_tonal);
                end
            end
        end
    end
end
fclose(handle);
% Write out information about tonals
Performance.falsePos = falsePos;

tock;

function detect = updPerformance(detect, gt_tonal, deviation, ...
    covered_s, excess_s, length_s)
% update statistics
detect.gt_match.add(gt_tonal);
detect.deviations(end+1) = deviation;
detect.covered_s(end+1) = covered_s;
detect.excess_s(end+1) = excess_s;
detect.length_s(end+1) = gt_tonal.duration();

function detect = initPerformance()
% detect = initPerformance()
% Given the number of detections and ground truth tonals, initialize
% a structure which tracks statistics on detections.
detect.detections = java.util.LinkedList();
detect.gt_match = java.util.LinkedList();
detect.gt_miss = java.util.LinkedList();
detect.deviations = [];
detect.gt_missed_N = NaN;  % computed at end
detect.fragment_rate = NaN;
detect.covered_s = [];
detect.length_s = [];
detect.excess_s = [];